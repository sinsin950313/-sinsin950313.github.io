# 항목 53 : 컴파일러 경고를 지나치지 말자
```cpp
class B
{
public:
    virtual void f() const;
};

class D : public B
{
public:
    virtual void f();
};
```
위 코드는 D::f가 B::f를 가린다는 warning을 발생시키는데, 이는 f가 재정의가 아니라 가린다는 것을 의미.
<br>
주로 사용하는 특정 컴파일러에서 내주는 경고 메시지들에 어느 정도 익숙해지고나면, 해당 메시지가 어떤 뜻으로 나온 건지를 슬슬 이해할 수 있음.
<br>
어떤 경고는 넘어가도 큰 문제는 없지만, 기본적으로 최고 수준의 경고를 걸더라도 경고 메시지가 없도록 작성하는 것이 좋음.
<br>
가장 중요한건 경고 메시지를 없애기 전에 그 경고가 알리려는 바가 어떤 것인가를 정확히 이해해야 한다는 것.
<br>
또한, 컴파일러는 제작사의 선택에 따라 달라지기 때문에 컴파일러의 경고만 믿고 아무 생각 없이 코드를 짜는 것도 좋지 않음.

## 정리
컴파일러 경고를 쉽게 지나치지 맙시다. 여러분의 컴파일러에서 지원하는 최고 경고 수준에도 경고 메시지를 내지 않고 컴파일되는 코드를 만드는 쪽에 전력을 다 하십시오.
<br>
컴파일러 경고에 너무 기대는 인생을 지양하십시오. 컴파일러마다 트집을 잡고 경고를 내는 부분들이 천차만별이기 때문입니다. 지금 코드를 다른 컴파일러로 이식하면서 여러분이 익숙해져 있는 경고 메시지가 온데 간데 없이 사라질 수도 있습니다.

# 항목 54 : TR1을 포함한 표준 라이브러리 구성요소와 편안한 친구가 되자
TR1은 이제 C++0x 또는 C++11에 다 반영되어 있는 것으로 알고있음.
<br>
현재 C++는 3년 주기로 기능을 올리는 것으로 알고 있으며 가장 최신 버전은 C++23.
<br>
최근에는 TR(Technical Report)이 아니라 TS(Technical Specification)이란 이름으로 나오는 것으로 알고있음.

## C++98에 명시된 표준 C++ 라이브러리의 주요 구성 요소
1. 표준 템플릿 라이브러리(STL) : 컨테이너, 반복자, 알고리즘, 함수 객체, 컨테이너 어댑터, 함수 객체 어댑터(stack, priority_queue, mem_fun, not1 등)
2. iostream : 사용자 정의 버퍼링, 국제화 기능이 가능한 입출력 지원. cin, cout, cerr, clog 등의 사전정의 객체 지원.
3. 국제화 지원 : 여러 로케일을 활성화시킬 수 있는 기능 포함. wchar_t 등의 타입(16비트 문자) 및 wstring(wchar_t 타입 string)을 쓰면 유니코드를 사용할 수 있음.
4. 수치 처리 지원 : 복소수, 수치 배열을 나타내는 템플릿(valarray)
5. 예외 클래스 계통 : exception과 파생 클래스(logic_error, runtime_error 등)
6. C89의 표준 라이브러리

## TR1에서 명시된 새로운 구성요소
1. 스마트 포인터 : std::shared_ptr, std::weak_ptr
```cpp
void registerCallback(std::string(int));
```
2. std::function : 함수가 가진 시그니처와 호환되는 시그니처를 갖는 함수 호출성 객체의 표현을 가능하게 해주는 템플릿. 타입간 암시적 변환도 지원.
3. std::bind : 상수 멤버 함수 및 비상수 멤버 함수 상관없이 동작. 참조로 전달되는 매개변수에 대해서도 동작. 외부 보조 없이 함수 포인터를 자체적으로 다룰 수 있음. 최근에는 그냥 std::function과 lambda를 이용하는게 더 편한걸로 알고있음.
4. 해시 테이블 : set, multiset, map, multimap 구현에 사용. unordered_set, unordered_multiset, unordered_map, unordered_multimap에도 사용
5. 정규 표현식
6. Tuplea : pair를 확장하는 2개 이상의 객체도 담을 수 있는 객체.
7. array : STL스럽게 작성된 배열. 즉, begin, end를 지원. 동적 메모리를 사용하지 않으므로 컴파일 타임에 크기가 고정됨.
8. mem_fn : 멤버 함수포인터를 adapt하는 용도로 쓸 수 있는 템플릿. std::function과 비슷한 용도로 보임. [참조](https://modoocode.com/254)
9. reference_wrapper : 참조자가 객체처럼 행동할 수 있음. 참조자를 담은것처럼 동작하는 컨테이너를 만들 수 있음.
10. 난수 발생 : 기존의 rand보다 우수함.
11. 특수 용도의 수학 함수 : Laguerre 다항식, Bessel 함수, 완전 타원 적분 등
12. C99 호환성 확장 기능
13. type traits : 주어진 타입에 대한 컴파일 타임 정보를 제공하는 특성 정보 클래스 모음. 기본 제공 타입, 가상 소멸자 지원 여부, 공백 클래스, 적절한 바이트 정렬, 암시적 변환 가능 여부 등
14. result_of : 함수 호출의 반환 타입을 추론해주는 템플릿. 어떤 (템플릿)함수의 호출로 인해 반환되는 객체의 타입을 참조할 수 있음. 최근 버전은 decltype이랑 auto를 사용하는 것으로 알고 있음. [참조](https://stackoverflow.com/a/2689761/8106257)

## 정리
최초에 상정된 표준 C++ 라이브러리의 주요 구성 요소는 STL, iostream, 로케일 등입니다. 여기에는 C89의 표준 라이브러리도 포함되어 있습니다.
<br>
TR1이 도입되면서 추가된 것은 스마트 포인터, 일반화 함수 포인터(std::function), 해시 기반 컨테이너, 정규 표현식, 그리고 그 외의 10개 구성요소입니다.
<br>
TR1 자체는 단순히 명세서일 뿐입니다. TR1의 기능을 사용하기 위해서는 명세를 구현한 코드를 구해야합니다. TR1 구현을 구할 수 있는 자료처 중 한 군데가 바로 부스트입니다.

# 항목 55 : Boo子有親! 부스트를 늘 여러분 가까이에
Boost의 관계자 대부분이 CPP 표준 위원회에 속해있어서 CPP의 대부분의 신규 기능이 Boost를 통해 미리 도입되거나 Boost에 있는 기능 대부분이 CPP 개정판에 포함되는 것으로 알고있음. 지금도 신규 기능을 미리 Boost를 통해 선보이는 듯.
<br>
Boost는 라이브러리 승인 과정에서 Peer Review를 거치는데, 이를 통해 설계와 구현의 우수성, 이식 가능 코드, 라이브러리가 실제로 도움을 줄 수 있는가, 문서가 명료하고 완전하고 정확하게 되어있는지를 검사한다.
<br>
즉, 업계 수준의 교차 플랫폼 라이브러리를 설계, 구현하고 문서화하는 방법을 익힐 수 있음.

## Boost의 분야
1. 문자열 및 텍스트 처리
2. 컨테이너
3. 함수 객체 및 고차 프로그래밍 : 람다 등의 기능 지원
4. 일반화 프로그래밍 : type traits
5. 템플릿 메타프로그래밍
6. 수학 및 수치 조작
7. 정확성 유지 및 테스트
8. 자료 구조
9. 타 언어와의 연동 지원
10. 메모리
11. 기타 : CRC, 날짜 및 시간 조작, 파일 시스템 횡단 등

## 정리
부스트는 동료 심사를 거쳐 등록되고 무료로 배포되는 오픈 소스 C++ 라이브러리를 개발하는 모임이자 웹사이트입니다. 또한 C++ 표준화에 있어서 영향력 있는 역할을 맡고 있습니다.
<br>
부스트에서 배포되는 라이브러리들 중엔 TR1 구성요소에 들어간 것도 있지만, 그 외에 다른 라이브러리들도 아주 많습니다.
