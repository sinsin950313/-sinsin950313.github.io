# 항목 22 : Pimpl 관용구를 사용할 때에는 특수 멤버 함수들을 구현 파일에서 정의하라.
##### Pimpl : Pointer + Implment - Pimple(여드름)이라 읽음

```cpp
// C++98
class Widget
{
public:
    Widget();

private:
    std::string name;
    std::vector<double> data;
    Gadget g1, g2, g3;
};

// C++11
// h
class Widget
{
public:
    Widget();
    ~Widget();
    Widget(const Widget&& rhs);
    Widget& operator=(const Widget&& rhs);
    Widget(const Widget& rhs);
    Widget& operator=(const Widget& rhs);

private:
    struct Impl;
    Impl* pImpl;                    // C++98
    std::unique_ptr<Impl> pImpl;    // C++11
};

// cpp
#include "Widget.h"
#include "Gadget.h"
#include <string>
#include <vector>

struct Widget::Impl
{
    std::string name;
    std::vector<double> data;
    Gadget g1, g2, g3;
};

// C++98
Widget::Widget() : pImpl(new Impl) { }
Widget::~Widget() { delete pImpl; }

// C++11
Widget::Widget() : pImpl(std::make_unique<Impl>()) { }
Widget::~Widget() = default;
Widget::Widget(const Widget&& rhs) = default;
Widget& Widget::operator=(const Widget&& rhs) = default;
Widget::Widget(const Widget& rhs) : pImp(nullptr)
{
    if(rhs.pImpl)
    {
        pImpl = std::make_unique<Impl>(*rhs.pImpl);
    }
}
Widget& Widget::operator=(const Widget& rhs)
{
    if(!rhs.pImpl)
    {
        pImpl.reset();
    }
    else if(!pImpl)
    {
        pImpl = std::make_unique<Impl>(*rhs.pImpl);
    }
    else
    {
        *pImpl = *rhs.pImpl;
    }

    return *this;
}

// Use
#include "Widget.h"

Widget w;
```
header에 선언했던 멤버 자료 형식을 cpp파일로 옮기는 기법
<br>
컴파일 타임을 줄이고 클라이언트가 헤더의 내용에 의존하는 것을 줄일 수 있음(Widget의 내부 정보를 구현하는 파일에서만 확인할 수 있음)
<br>
header에서 선언한 멤버 자료 형식을 cpp파일로 옮기고 객체의 동적 할당과 삭제를 명시해야 함.

만약 C++11 방식을 이용해서 pImpl을 사용한다면 불완전한 형식으로 인해 pImpl을 삭제할 수 없다는 컴파일러 에러가 발생할 것이다.
<br>
이는 std::unique_ptr이 pImpl을 삭제하는 시점에 static_assert를 사용하여 해당 포인터가 불완전한 형식을 가리키지는 않는지 점검하는데, header 파일만으로는 pImpl의 형식이 완전하지 않기 때문
<br>
이를 막기위해 cpp파일 내부에 명시적으로 소멸자를 선언해줘야 한다
<br>
비슷한 이유로 move 연산자도 함께 선언해줘야 move 연산이 지원된다
<br>
복사 연산자의 경우 std::unique_ptr로 인해 따로 작성해줘야 한다. 이 때 pImpl이 nullptr인지 점검하는 구문이 필요하다는 점에 유의하라

```cpp
// h
class Widget
{
public:
    Widget();

private:
    struct Impl;
    std::shared_ptr<Impl> pImpl;    // C++11
};

// cpp
#include "Widget.h"
#include "Gadget.h"
#include <string>
#include <vector>

struct Widget::Impl
{
    std::string name;
    std::vector<double> data;
    Gadget g1, g2, g3;
};

Widget::Widget() : pImpl(std::make_unique<Impl>()) { }

// Use
#include "Widget.h"

Widget w1;
auto w2 = std::move(w1);
w1 = std::move(w2);
```
pImpl에 사용하기 적합한 Smart Pointer가 std::unique인 것이 의미론적으로 적합하지만, 만약 std::shared_ptr을 사용하는 경우에는 필요한 코드 작성의 양이 획기적으로 줄어든다.

## 정리
pImpl 관용구는 클래스 구현과 클래스 클라이언트 사이의 컴파일러 의존성을 줄임으로써 빌드 시간을 감소시킨다.
<br>
std::unique_ptr 형식의 pImpl 포인터를 사용할 때에는 특수 멤버 함수들을 클래스 헤더에 선언하고 구현 파일에서 구현해야 한다. 컴파일러가 기본으로 작성하는 함수 구현들이 사용하기에 적합한 경우에도 그렇게 해야한다.
<br>
위의 조언은 std::unique_ptr에 적용될 뿐, std::shared_ptr에는 적용되지 않는다.