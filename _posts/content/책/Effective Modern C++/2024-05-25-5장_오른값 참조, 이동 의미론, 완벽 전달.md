---
title: "5장 - 오른값 참조, 이동 의미론, 완벽 전달"
date: 2024-05-26
categories: ["책", "C++", "Modern C++"]
tags: ["cpp", "c++"]
---

# 개요
## Move semantics
유효한 문맥에서 컴파일러는 비싼 복사 연산을 덜 비싼 이동 연산으로 대체할 수 있음
<br>
std::unique_ptr나 std::future, std::thread같은 이동 전용 형식의 작성을 가능하게 함.
<br>
이동의 원본이 될 수 있는 객체를 지정하는 것

## Perfect Forwarding
임의의 인수들을 받아서 그것들을 다른 함수(대상 함수)로 전달하는 함수를 작성할 때, 그 대상 함수가 애초에 전달 함수가 받은 것과 정확히 같은 인수들을 받게 만들 수 있음.

```cpp
void f(Widget&& w);
```
이번 장의 항목들에서는 매개변수가 항상 lvalue라는 점을 명심하는 것이 중요하다.
<br>
즉, w는 Widget에 대하여 rvalue reference이지만 w는 lvalue이다.(용어와 관례에 나오는 왼값과 오른값에 관한 논의를 다시 읽어봐라)

# 항목 23 : std::move와 std::forward를 숙지하라
std::move와 std::forward는 실행 시점에 아무것도 하지 않는다. 이들은 실행 가능 코드를 산출하지 않는다. 이 함수들은 casting 함수이다. 즉, std::move는 rvalue로 casting, std::forward는 조건이 만족될 때에만 casting을 수행한다.

```cpp
template<typename T>
typename remove_reference<T>::type&& move(T&& param)
{
    using ReturnType = typename remove_reference<T>::type&&;

    return static_cast<ReturnType>(param);
}
```
std::move는 객체에 대한 (보편)참조를 받아서 같은 객체에 대한 어떤 참조를 돌려준다.
<br>
이 때 T가 lvalue reference라면 반환 값도 lvalue가 되기 때문에 reference를 제거하고 move함수는 항상 rvalue를 반환한다.
<br>
결론적으로 std::move는 자신의 인수를 rvalue로 casting한다.
<br>
std::move는 rvalue casting을 수행하지만 move를 수행하지는 않는다. 다만 rvalue는 move에 적합한 후보일 뿐이다.

```cpp
class Annotation
{
public:
    explicit Annotation(const std::string text) : value(std::move(text)) { ... }

private:
    std::string text;
};

class string
{
public:
    string(const string& rhs);
    string(string&& rhs);
};
```
Annotation의 인수로 들어가는 text는 const 형식으로 std::string의 const성을 유지하기 위해 복사 생성된다.
<br>
즉, rvalue라 하더라도 항상 move되지는 않는다.
<br>
이동을 지원하는 객체는 const로 선언하지 말아야 한다. const 객체에 대한 이동 요청은 암묵적으로 복사 연산으로 변환된다.
<br>
std::move는 아무것도 실제로 이동하지 않을 뿐만 아니라, casting되는 객체가 이동 자격을 갖추게 된다는 보장도 제공하지 않는다. 단지 std::move를 적용한 결과가 하나의 rvalue라는 것 뿐이다.

```cpp
void process(const Widget& lValArg);
void process(Widget&& rValArg);

template<typename T>
void logAndProcess(T&& param)
{
    auto now = std::chrono::system_clock::now();

    makeLogEntry("Calling 'process'", now);
    process(std::forward<T>(param));
}

Widget w;

logAndProcess(w);
logAndProcess(std::move(w));
```
std::forward는 특정 조건이 만족될 때만 casting하는 조건부 캐스팅이다. 가장 흔하게 사용되는 시나리오는 보편 참조 매개변수를 받아서 그것을 다른 어떤 함수에게 전달하는 함수이다.
<br>
위 코드는 Widget w를 lvalue와 rvalue로 호출하고자 한다. 그러나 logAndProcess의 매개변수 T&& param은 lvalue이기 때문에 std::forward가 없으면 모두 lvalue로 overloading된 함수가 호출된다.
<br>
즉, std::forward는 인자로 들어온 값의 type을 그대로 전달하는 역할을 한다. std::forward가 lvalue와 rvalue를 복구하는 방식은 항목 28을 참조.

## 정리
std::move는 rvalue로의 무조건 casting을 수행한다. std::move 자체는 아무것도 이동하지 않는다.
<br>
std::forward는 주어진 인수가 rvalue에 묶인 경우에만 그것을 rvalue로 casting한다.
<br>
std::move와 std::forward 둘 다, 실행시점에서는 아무 일도 하지 않는다.

# 항목 24 : Universal Reference와 Rvalue Reference를 구별하라
```cpp
void f(Widget&& param);         // rvalue reference

Widget&& var1 = Widget();       // rvalue reference

auto&& var2 = var1;             // universal reference

template<typename T>
void f(std::vector<T>&& param); // rvalue reference

template<typename T>
void f(T&& param);              // universal reference
```
Universal reference는 rvalue reference 또는 lvalue reference 중 하나라는 것을 의미
<br>
const, non-const, volatile, non-volatile 등 모든 것에 묶을 수 있음.

Universal Reference는 함수 템플릿 매개변수, auto에서 발생. 즉, 형식 연역이 일어나는 곳에서 발생
<br>
Universal Reference는 결국 Reference이기 때문에 초기화가 필요하다. Universal Reference가 lvaue인지 rvalue인지는 초기치가 결정한다. Universal Reference가 함수의 매개변수이면 초기치는 함수를 호출하는 지점에서 제공한다.
<br>
Universal Reference는 또한 Reference 선언의 형태(Form)도 정확해야 한다. 즉, T&&의 형태이어야 한다. const 한정사가 붙어도 Universal Reference가 될 수 없음

```cpp
template<typename T, class Allocator = allocator<T>>
class vector
{
public:
    void push_back(T&& param);

    template<class... Args>
    void emplace_back(Args&&... args);
}
```
즉, 형식 연역과 선언의 형태가 정확해야 Universal Reference이다.
<br>
push_back은 vector를 선언하는 시점에 T가 이미 결정되어있으므로 함수 호출 지점에서는 형식 연역이 발생하지 않으므로 RValue reference이다.
<br>
emplace_back은 형식 매개변수 T와 독립적이므로 emplace_back이 호출되는 시점에 Args가 연역되어야 하므로 Universal Reference이다.

Universal Reference는 Reference Collapsing으로 인해 연역 규칙이 결정된다.(항목 28 참조)

## 정리
함수 템플릿 매개변수의 형식이 T&& 형태이고 T가 연역된다면, 또는 객체를 auto&&로 선언한다면, 그 매개변수나 객체는 Universal Reference이다.
<br>
형식 선언의 형태가 정확히 T&&가 아니면, 또는 형식 연역이 일어나지 않으면, T&&는 RValue Reference를 의미한다.
<br>
Rvalue로 초기화되는 Universal Reference는 RValue에 해당한다. LValue오 초기화되는 Universal Reference는 LValue에 해당한다.

# 항목 25 : RValue에는 std::move를, Universal Reference에는 std::forward를 사용하라
RValue Reference에 묶이는 객체는 이동할 수 있는 객체를 의미한다. Univesal Reference에 묶이는 객체는 이동에 적합한 객체에 묶일 수도 있고 아닐 수도 있다.

```cpp
class Widget
{
public:
    template<typename T>
    void setName(T&& newName) { name = std::move(newName); }    // Universal Reference를 std::move로 이동

private:
    std::string name;
    std::shared_ptr<SomeDataStructure> p;
};

std::string GetWidgetName();    // 팩토리 함수

Widget w;
auto n = GetWidgetName();       // n은 지역변수
w.setName(n);                   // 이제 n의 값은 알 수 없음 
```
Universal Reference에 std::move를 사용하면 lvalue를 의도치않게 rvalue로 변형하는 일이 발생할 수 있음

```cpp
class Widget
{
public:
    void setName(const std::string& newName) { name = newName; }
    void setName(std::string&& newName) { name = std::move(newName); }
}

w.setName("Adela Novak");
```
템플릿을 사용하지 않고 lvalue와 rvalue를 인자로 받는 함수를 overloading할 수도 있지만 유지보수해야 할 코드가 늘어나고 효율성이 떨어지는 단점이 있음.
<br>
위 코드는 만약 template을 사용했다면 "Adela Novak"가 const char*로 넘어가서 바로 name의 할당 생성자의 매개변수로 사용되었겠지만, overloading을 하므로써 불필요한 임시 객체 std::string이 생성되고 , 이동하고, 삭제되어야 한다.
<br>
가장 큰 문제는 매개변수가 늘어날 수록 overloading해야하는 함수의 개수가 기하급수적으로 늘어날 수 있다는 점.
<br>
심지어 가변 길이 템플릿의 overloading은 구현이 불가능하다.

```cpp
template<typename T>
T operator+(T&& lhs, const T& rhs)   // return by value
{
    lhs += rhs;
    return std::forward<T>(lhs);  // lhs를 반환값으로 이동
}

template<typename T>
T operator+(T&& lhs, const T& rhs)   // return by value
{
    lhs += rhs;
    return lhs; // lhs를 반환값으로 복사
}
```
Return by Value 함수에서 반환 값이 Rvalue Refernce나 Universal Reference에 묶인 객체는 return 문에서 std::move나 std::forward를 사용하는 것이 좋다.

```cpp
Widget makeWidget() // 복사 버전
{
    Widget w;
    ...
    return w;
}

Widget makeWidget(Widget w) // 반환값과 형식이 같은 값 전달 방식의 매개변수를 반환하는 함수
{
    ...
    return w;
}

Widget makeWidget() // 이동 버전
{
    Widget w;
    ...
    return std::move(w);    // 올바르지 못한 사용
}
```
함수가 반환될 지역 변수에서 std::move를 쓰는것은 추천하지 않는다.
<br>
'복사'를 '이동'으로 바꿈으로써 함수를 '최적화'할 수 있는 것은 아니다.
<br>
Return Value Optimization(RVO)라고 하는 이것은 만일 지역 변수 w를 함수의 반환값을 위해 마련한 메모리 안에 생성한다면 w의 복사를 피할 수 있다는 개념은 컴파일러에 의해 자동으로 최적화된다.

    1. 그 지역 객체의 형식이 함수의 반환 형식과 같아야 한다.
    2. 그 지역 객체가 바로 함수의 반환값이어야 한다.

즉, 위 코드의 복사 버전은 사실 아무것도 복사하지 않는다.
<br>
하지만 이동 버전은 2번 조건에 위배(w에 대한 참조를 반환)되어 실제로 컴파일러가 할 수 있는 최적화 여지를 제한한다.
<br>
마지막으로 반환값 최적화의 필수 조건들이 성립했지만 컴파일러가 복사 제거를 수행하지 않기로 한 경우, 반환되는 객체는 반드시 RValue로 취급되어야 한다고 명시되어 있기 때문에 반환되는 객체는 암묵적으로 std::move가 적용된다.
<br>
이는 매개변수로 전달된 상황에서도 유사하게 적용되어 위 코드의 2번째 예시가 그러하다.

## 정리
RValue Refernce나 Universal Reference가 마지막으로 쓰이는 지점에서, RValue Reference는 std::move를, Universal Reference는 std::forward를 적용해라
<br>
결과를 값 전달 방식으로 돌려주는 함수가 RValue Reference나 Universal Reference를 돌려줄 때에도 각각 std::move나 std::forward를 적용해라
<br>
반환값 최적화의 대상이 될 수 있는 지역 객체에는 절대로 std::move나 std::forward를 적용하지 말아라.

# 항목 26 : Universal Reference에 대한 Overloading을 피하라
```cpp
std:: multiset<std::string> names;

void logAndAdd(const std::string& name)
{
    auto now = std::chrono::system_clock::now();
    log(now, "logAndAdd");
    names.emplace(name);
}

std::string petName("Darla");
logAndAdd(petName);                     // lvalue std::string
logAndAdd(std::string("Persephone"));   // rvalue std::string
logAndAd("Patty Dog");                  // const char*
```
1번 호출은 lvalue name이 emplace로 넘어가 names에 복사된다. 복사를 피할 방법은 없다.
<br>
2번 호출은 rvalue가 name에 복사된다. 이 복사는 하지 않을 여지가 있다.
<br>
3번 호출은 std::string 임시 객체가 생성되고 names에 복사된다. 임시 객체 생성과 복사는 하지 않을 여지가 있다.

```cpp
template<typename T>
void logAndAdd(T&& name)
{
    auto now = std::chrono::system_clock::now();
    log(now, "logAndAdd");
    names.emplace(std::forward<T>(name));
}

std::string petName("Darla");
logAndAdd(petName);                     // lvalue std::string
logAndAdd(std::string("Persephone"));   // rvalue std::string
logAndAd("Patty Dog");                  // const char*
```
forward를 이용하여 최적의 효율을 달성할 수 있다.

```cpp
std::string nameFromIndex(int index);

void logAndAdd(int index)
{
    auto now = std::chrono::system_clock::now();
    log(now, "logAndAdd");
    names.emplace(nameFromIndex(index));
}

logAndAdd(22);          // 정상 작동

short nameIndex = 22;
logAndAdd(nameIndex);   // compile error
```
overloading을 하면 예상치 못한 상황에서 문제가 발생할 수 있음
<br>
위 코드는 short를 int로 승격(promotion)을 기대했지만 T를 short&로 연역하는 상황이 주어진 인수와 정확히 부합하는 형태가 되므로 Universal Reference overloading 함수가 호출되면서 문제가 발생한다.
<br>
Universal Referencd를 받는 템플릿 함수는 C++에서 가장 욕심이 많은 함수로 템플릿 인스턴스의 거의 모든 형식의 인수와 정확히 부합한다. 즉, 보편 참조 중복 적재를 시도한 개발자가 일반적으로 예쌍한 것보다 훨씬 많은 인수 형식들을 빨아들인다.

```cpp
class Person
{
public:
    template<typename T>
    explicit Person(T&& n) : name(std::forward<T>(n)) { }

    explicit Person(int index) : name(nameFromIndex(index)) { }

    Person(const Person& rhs);  // compiler가 작성

    Person(Person&& rhs);       // compiler가 작성

private:
    std::string name;
};

Person p("Nancy");
auto cloneOfP(p);   // compile error. template 인스턴스 생성자

const Person p("Nancy")
auto cloneOfP(p)    // 복사 생성자
```
위 코드는 non-const Person type을 이용하여 복사 생성하려는 의도였지만 컴파일을 실패한다.
<br>
컴파일러는 non-const Person type으로 템플릿을 인스턴스화하는 것과 const로 casting하여 복사 생성하는 것 중 템플릿을 인스턴스화 하는 것이 정확하게 부합하므로 name에 Person 객체가 넘어가면서 컴파일에 실패한다.
<br>
참고로 함수 호출이 템플릿 인스턴스와 비템플릿 함수에 똑같이 부합한다면 일반 함수를 우선시하는 규칙이 있으므로 const Person 인자로 주면서 템플릿이 T를 const Person&으로 해석해도 정상적으로 호출된다.

```cpp
class SpecialPerson : Person
{
public:
    SpecialPerson(const SpecialPerson& rhs) : Person(rhs) { ... }   // template 인스턴스 생성자 호출
    SpecialPerson(SpecialPerson&& rhsl) : Person(rhs) { ... }       // template 인스턴스 생성자 호출
};
```
이러한 중복적재는 파생 클래스에서의 경우 더욱 예상치 못한 행동을 보일 수 있음
<br>
위 코드 역시 템플릿 인스턴스화 중복적재 해소 과정을 짚어보면 이해할 수 있음
<br>
즉, Universal Reference의 중복 적재는 피해야 한다. 그 방법은 다음 항목에서 계속.

## 정리
보편 참조에 대한 중복 적재는 거의 항상 보편 참조 중복적재 버전이 예상보다 자주 호출되는 상황으로 이어진다.
<br>
완벽 전달 생성자들은 특히나 문제가 많다. 그런 생성자는 대체로 non-const lvalue에 대한 복사 생성자보다 더 나은 부합이며, 기반 클래스 복사 및 이동 생성자들에 대한 파생 클래스의 호출들을 가로챌 수 있기 때문이다.

### 참고
여기서 이야기하는 중복 적재가 Person(int) 생성자가 추가되어서 그런건가 헷갈릴수도 있는데 그건 아니고 그냥 template을 사용하는 상황에서 입력 인자로 줄 수 있는 모든 값으로 인해 발생할 템플릿 인스턴스화에 대한 이야기를 의미
<br>
https://godbolt.org/z/aqn689Go1
<br>
위 사이트를 보면 Person(int)를 정의하지 않았지만 non-const 형식은 컴파일되지 않는 것을 확인할 수 있음